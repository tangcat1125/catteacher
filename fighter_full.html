// ... (keep all existing code) ...

// --- Input Handling ---
// Keep existing keyboard handlers
window.addEventListener('keydown', (e) => {
    // Don't process game keys if game over screen is waiting for Enter
    if (isGameOver && e.key !== 'Enter') return;
    keysPressed[e.key] = true;
    if ([' ', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        e.preventDefault();
    }
});

window.addEventListener('keyup', (e) => {
    keysPressed[e.key] = false;
});

// --- NEW: Mobile Touch Controls Setup ---
function setupMobileControls() {
    const btnUp = document.getElementById('btnUp');
    const btnDown = document.getElementById('btnDown');
    const btnLeft = document.getElementById('btnLeft');
    const btnRight = document.getElementById('btnRight');
    const btnFire = document.getElementById('btnFire');
    // const btnMissile = document.getElementById('btnMissile'); // If you add it

    // Mapping from button ID to the key it simulates
    const keyMap = {
        'btnUp': 'ArrowUp',
        'btnDown': 'ArrowDown',
        'btnLeft': 'ArrowLeft',
        'btnRight': 'ArrowRight',
        'btnFire': ' ', // Space key for firing
        // 'btnMissile': 'm' // If you add missile button
    };

    const buttons = [btnUp, btnDown, btnLeft, btnRight, btnFire]; // Add btnMissile here if used

    buttons.forEach(button => {
        if (!button) return; // Skip if a button wasn't found

        const key = keyMap[button.id];
        if (!key) return; // Skip if no key mapping exists

        // When touch starts on a button
        button.addEventListener('touchstart', (e) => {
            if (isGameOver) return; // Don't allow input if game over
            e.preventDefault(); // Important: Prevent scrolling/zooming
            keysPressed[key] = true;
            button.style.backgroundColor = 'rgba(200, 200, 200, 0.8)'; // Visual feedback
        }, { passive: false }); // Need passive: false to allow preventDefault

        // When touch ends *anywhere* after starting on the button
        // Or when touch leaves the button boundary
        const touchEndHandler = (e) => {
             // Check if the touch causing the end originated on this button
            // This is a bit tricky, simpler to just set the key to false on any touchend/leave
            // if (isGameOver) return; // Allow releasing keys even if game over? Maybe not.
             keysPressed[key] = false;
             button.style.backgroundColor = ''; // Reset visual feedback

             // We might need to remove other listeners if we add them dynamically
        };

        button.addEventListener('touchend', touchEndHandler);
        button.addEventListener('touchcancel', touchEndHandler); // Handle cancellations (e.g., alert popup)
        // Optional: Handle touch leaving the button area while still pressed
        button.addEventListener('touchmove', (e) => {
            if (isGameOver) return;
            e.preventDefault(); // Prevent scroll during drag over button
            // Check if the touch point moved outside the button's bounds
            const touch = e.touches[0]; // Get the first touch point
            const rect = button.getBoundingClientRect();
            if (touch.clientX < rect.left || touch.clientX > rect.right ||
                touch.clientY < rect.top || touch.clientY > rect.bottom) {
                 // If touch moved off the button, treat it as a key release
                 if (keysPressed[key]) { // Only trigger if it was pressed
                     keysPressed[key] = false;
                     button.style.backgroundColor = ''; // Reset visual feedback
                 }
            } else {
                 // If touch moved back onto the button, treat it as pressed again
                 // (This might feel weird, maybe only reactivate on new touchstart)
                 // keysPressed[key] = true;
                 // button.style.backgroundColor = 'rgba(200, 200, 200, 0.8)';
            }

        }, { passive: false });


    });

     // Add a listener to the whole document to catch touchend events
     // that might happen outside the original button area. This helps
     // prevent "stuck" keys if the finger slides off quickly.
    document.addEventListener('touchend', (e) => {
        // Iterate through all known keys and set them to false
        // This is a safety net, might cause issues if multiple touches are intended
        // A more robust solution involves tracking individual touch identifiers (e.g., e.changedTouches)
        Object.keys(keyMap).forEach(buttonId => {
            const key = keyMap[buttonId];
            keysPressed[key] = false;
             // Also reset visual style for all buttons (could be optimized)
             const btn = document.getElementById(buttonId);
             if(btn) btn.style.backgroundColor = '';
        });

    });
}


// --- Game Control ---
function gameOver() {
    if (isGameOver) return;
    isGameOver = true;
    console.log("Game Over!");
    // Clear any active key presses to stop movement/firing
    keysPressed = {}; // Reset keys state
    drawGameOver();
}

function restartGame() {
    console.log("Restarting game...");
    // ...(existing restart logic)...
    keysPressed = {}; // Ensure keys are cleared on restart

    // Reset button visual state (important if game over happens during a touch)
    const buttons = document.querySelectorAll('.control-button');
    buttons.forEach(button => {
        button.style.backgroundColor = '';
    });

    // ...(rest of existing restart logic)...

    // Re-enable controls (they might have been disabled in gameOver logic if needed)
    // No specific disabling done here currently, so just proceed.

    requestAnimationFrame(gameLoop);
}

// --- Initialization ---
function init() {
    player = new Player();
    lastTime = performance.now();
    gameStartTime = performance.now();
    setupMobileControls(); // <<< ADD THIS CALL
    requestAnimationFrame(gameLoop);
}

// Start the game when the script loads
init();
